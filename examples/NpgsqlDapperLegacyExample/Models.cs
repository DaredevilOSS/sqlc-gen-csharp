// auto-generated by sqlc - do not edit
using NodaTime;
using NodaTime.Extensions;
using NpgsqlTypes;
using System;
using System.Collections.Generic;
using System.Linq;
using System.Net;
using System.Net.NetworkInformation;
using System.Text.Json;
using System.Xml;

namespace NpgsqlDapperLegacyExampleGen;
public class Author
{
    public required long Id { get; init; }
    public required string Name { get; init; }
    public string? Bio { get; init; }
};
public class Book
{
    public required Guid Id { get; init; }
    public required string Name { get; init; }
    public required long AuthorId { get; init; }
    public string? Description { get; init; }
};
public class PostgresNumericType
{
    public bool? CBoolean { get; init; }
    public byte[]? CBit { get; init; }
    public short? CSmallint { get; init; }
    public int? CInteger { get; init; }
    public long? CBigint { get; init; }
    public decimal? CDecimal { get; init; }
    public decimal? CNumeric { get; init; }
    public float? CReal { get; init; }
    public double? CDoublePrecision { get; init; }
    public decimal? CMoney { get; init; }
};
public class PostgresStringType
{
    public string? CChar { get; init; }
    public string? CVarchar { get; init; }
    public string? CCharacterVarying { get; init; }
    public string? CBpchar { get; init; }
    public string? CText { get; init; }
};
public class PostgresDatetimeType
{
    public DateTime? CDate { get; init; }
    public TimeSpan? CTime { get; init; }
    public DateTime? CTimestamp { get; init; }
    public DateTime? CTimestampWithTz { get; init; }
    public TimeSpan? CInterval { get; init; }
    public DateTime? CTimestampNodaInstantOverride { get; init; }
};
public class PostgresNetworkType
{
    public NpgsqlCidr? CCidr { get; init; }
    public IPAddress? CInet { get; init; }
    public PhysicalAddress? CMacaddr { get; init; }
    public string? CMacaddr8 { get; init; }
};
public class PostgresArrayType
{
    public byte[]? CBytea { get; init; }
    public bool[]? CBooleanArray { get; init; }
    public string[]? CTextArray { get; init; }
    public int[]? CIntegerArray { get; init; }
    public decimal[]? CDecimalArray { get; init; }
    public DateTime[]? CDateArray { get; init; }
    public DateTime[]? CTimestampArray { get; init; }
};
public class PostgresGeometricType
{
    public NpgsqlPoint? CPoint { get; init; }
    public NpgsqlLine? CLine { get; init; }
    public NpgsqlLSeg? CLseg { get; init; }
    public NpgsqlBox? CBox { get; init; }
    public NpgsqlPath? CPath { get; init; }
    public NpgsqlPolygon? CPolygon { get; init; }
    public NpgsqlCircle? CCircle { get; init; }
};
public class PostgresSpecialType
{
    public Guid? CUuid { get; init; }
    public CEnum? CEnum { get; init; }
    public JsonElement? CJson { get; init; }
    public JsonElement? CJsonStringOverride { get; init; }
    public JsonElement? CJsonb { get; init; }
    public string? CJsonpath { get; init; }
    public XmlDocument? CXml { get; init; }
    public XmlDocument? CXmlStringOverride { get; init; }
};
public class PostgresNotNullType
{
    public required CEnum CEnumNotNull { get; init; }
};
public class ExtendedBio
{
    public required string AuthorName { get; init; }
    public required string Name { get; init; }
    public ExtendedBioType? BioType { get; init; }
};
public enum CEnum
{
    Invalid = 0, // reserved for invalid enum value
    Small = 1,
    Medium = 2,
    Big = 3
}

public static class CEnumExtensions
{
    private static readonly Dictionary<string, CEnum> StringToEnum = new Dictionary<string, CEnum>()
    {
        [string.Empty] = CEnum.Invalid,
        ["small"] = CEnum.Small,
        ["medium"] = CEnum.Medium,
        ["big"] = CEnum.Big
    };
    private static readonly Dictionary<CEnum, string> EnumToString = new Dictionary<CEnum, string>()
    {
        [CEnum.Invalid] = string.Empty,
        [CEnum.Small] = "small",
        [CEnum.Medium] = "medium",
        [CEnum.Big] = "big"
    };
    public static string Stringify(this CEnum me)
    {
        return EnumToString[me];
    }
}

public enum ExtendedBioType
{
    Invalid = 0, // reserved for invalid enum value
    Autobiography = 1,
    Biography = 2,
    Memoir = 3
}

public static class ExtendedBioTypeExtensions
{
    private static readonly Dictionary<string, ExtendedBioType> StringToEnum = new Dictionary<string, ExtendedBioType>()
    {
        [string.Empty] = ExtendedBioType.Invalid,
        ["Autobiography"] = ExtendedBioType.Autobiography,
        ["Biography"] = ExtendedBioType.Biography,
        ["Memoir"] = ExtendedBioType.Memoir
    };
    private static readonly Dictionary<ExtendedBioType, string> EnumToString = new Dictionary<ExtendedBioType, string>()
    {
        [ExtendedBioType.Invalid] = string.Empty,
        [ExtendedBioType.Autobiography] = "Autobiography",
        [ExtendedBioType.Biography] = "Biography",
        [ExtendedBioType.Memoir] = "Memoir"
    };
    public static string Stringify(this ExtendedBioType me)
    {
        return EnumToString[me];
    }
}