using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using static Microsoft.CodeAnalysis.CSharp.SyntaxFactory;
using File = Plugin.File;

namespace SqlcGenCsharp.Generators;

internal class UtilsGen(string namespaceName, Options options)
{
    private const string ClassName = "Utils";

    private string NamespaceName { get; } = namespaceName;

    private RootGen RootGen { get; } = new(options);

    public File GenerateFile()
    {
        var root = RootGen.CompilationRootGen(
            IdentifierName(NamespaceName), GetUsingDirectives(), [GetUtilsClass()]);
        root = root.AddCommentOnTop(Consts.AutoGeneratedComment);

        return new File
        {
            Name = $"{ClassName}.cs",
            Contents = root.ToByteString()
        };
    }

    private static UsingDirectiveSyntax[] GetUsingDirectives()
    {
        return
        [
            UsingDirective(ParseName("System")),
            UsingDirective(ParseName("System.Data")),
            UsingDirective(ParseName("System.Linq")),
            UsingDirective(ParseName("System.Text.RegularExpressions"))
        ];
    }

    private MemberDeclarationSyntax GetUtilsClass()
    {
        var optionalTransformQueryForSqliteBatch = options.DriverName is DriverName.Sqlite
            ? """
              private static readonly Regex ValuesRegex = new Regex(@"VALUES\s*\((?<params>[^)]*)\)", RegexOptions.IgnoreCase);
              
              public static string TransformQueryForSqliteBatch(string originalSql, int cntRecords)
              {
                  var match = ValuesRegex.Match(originalSql);
                  if (!match.Success)
                      throw new ArgumentException("The query does not contain a valid VALUES clause.");
                  
                  var valuesParams = match.Groups["params"].Value
                      .Split(',')
                      .Select(p => p.Trim())
                      .ToList();
                  var batchRows = Enumerable.Range(0, cntRecords)
                      .Select(i => "(" + string.Join(", ", valuesParams.Select(p => $"{p}{i}")) + ")");
                      
                  var batchValuesClause = "VALUES " + string.Join(",\n", batchRows);
                  return ValuesRegex.Replace(originalSql, batchValuesClause);
              }
              """ :
            string.Empty;
        var utilsClassDeclaration = $$"""
           public static class {{ClassName}}
           {
               public static byte[] GetBytes(IDataRecord reader, int ordinal)
               {
                   const int bufferSize = 100000;
                   if (reader is null) throw new ArgumentNullException(nameof(reader));
                   var buffer = new byte[bufferSize];
                     
                   var (bytesRead, offset) = (0, 0);
                   while (bytesRead < bufferSize)
                   {
                       var read = (int) reader.GetBytes(
                           ordinal,
                           bufferSize + bytesRead,
                           buffer,
                           offset,
                           bufferSize - bytesRead);
                       if (read == 0)
                           break;
                       bytesRead += read;
                       offset += read;
                   }
               
                   if (bytesRead < bufferSize)
                       Array.Resize(ref buffer, bytesRead);
                   return buffer;
               }

               public static string TransformQueryForSliceArgs(string originalSql, int sliceSize, string csharpParamName, string sqlParamName)
               {
                   var paramArgs = Enumerable.Range(0, sliceSize).Select(i => $"@{csharpParamName}Arg{i}").ToList();
                   return originalSql.Replace($"/*SLICE:{sqlParamName}*/@{sqlParamName}", string.Join(",", paramArgs));
               }
               
               {{optionalTransformQueryForSqliteBatch}}
           }
           """;
        return ParseMemberDeclaration(utilsClassDeclaration)!.NormalizeWhitespace();
    }
}