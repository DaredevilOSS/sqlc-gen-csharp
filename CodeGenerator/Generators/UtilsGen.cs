using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using SqlcGenCsharp.Drivers;
using System.Collections.Generic;
using System.Linq;
using static Microsoft.CodeAnalysis.CSharp.SyntaxFactory;
using File = Plugin.File;

namespace SqlcGenCsharp.Generators;

internal class UtilsGen(DbDriver dbDriver, string namespaceName)
{
    private const string ClassName = "Utils";

    private string NamespaceName { get; } = namespaceName;

    private RootGen RootGen { get; } = new(dbDriver.Options);

    public File GenerateFile()
    {
        var root = RootGen.CompilationRootGen(
            IdentifierName(NamespaceName), GetUsingDirectives(), [GetUtilsClass()]);
        root = root.AddCommentOnTop(Consts.AutoGeneratedComment);

        return new File
        {
            Name = $"{ClassName}.cs",
            Contents = root.ToByteString()
        };
    }

    private UsingDirectiveSyntax[] GetUsingDirectives()
    {
        IEnumerable<UsingDirectiveSyntax> usingDirectives =
        [
            UsingDirective(ParseName("System")),
            UsingDirective(ParseName("System.Data")),
            UsingDirective(ParseName("System.Linq")),
            UsingDirective(ParseName("System.Text.RegularExpressions"))
        ];

        if (dbDriver.Options.DriverName is DriverName.MySqlConnector)
        {
            usingDirectives = usingDirectives.Concat([
                UsingDirective(ParseName("CsvHelper.TypeConversion")),
                UsingDirective(ParseName("CsvHelper")),
                UsingDirective(ParseName("CsvHelper.Configuration"))
            ]);
        }

        return usingDirectives.ToArray();
    }

    private MemberDeclarationSyntax GetUtilsClass()
    {
        var optionalTransformQueryForSqliteBatch = dbDriver.Options.DriverName is DriverName.Sqlite
            ? """
              private static readonly Regex ValuesRegex = new Regex(@"VALUES\s*\((?<params>[^)]*)\)", RegexOptions.IgnoreCase);
              
              public static string TransformQueryForSqliteBatch(string originalSql, int cntRecords)
              {
                  var match = ValuesRegex.Match(originalSql);
                  if (!match.Success)
                      throw new ArgumentException("The query does not contain a valid VALUES clause.");
                  
                  var valuesParams = match.Groups["params"].Value
                      .Split(',')
                      .Select(p => p.Trim())
                      .ToList();
                  var batchRows = Enumerable.Range(0, cntRecords)
                      .Select(i => "(" + string.Join(", ", valuesParams.Select(p => $"{p}{i}")) + ")");
                      
                  var batchValuesClause = "VALUES " + string.Join(",\n", batchRows);
                  return ValuesRegex.Replace(originalSql, batchValuesClause);
              }
              """ :
            string.Empty;

        var optionalNullToNStringConverter = dbDriver.Options.DriverName is DriverName.MySqlConnector
            ? $$"""
                public class NullToStringConverter : DefaultTypeConverter
                {
                    public override {{dbDriver.AddNullableSuffixIfNeeded("string", true)}} ConvertToString(
                        {{dbDriver.AddNullableSuffixIfNeeded("object", false)}} value, IWriterRow row, MemberMapData memberMapData)
                    {
                        return value == null ? @"\N" : base.ConvertToString(value, row, memberMapData);
                    }
                }
                
                public class BoolToBitConverter : DefaultTypeConverter
                {
                    public override {{dbDriver.AddNullableSuffixIfNeeded("string", true)}} ConvertToString(
                    {{dbDriver.AddNullableSuffixIfNeeded("object", false)}} value, IWriterRow row, MemberMapData memberMapData)
                    {
                        switch (value)
                        {
                            case null:
                                return @"\N";
                            case bool b:
                                return b ? "1" : "0";
                            default:
                                return base.ConvertToString(value, row, memberMapData);
                        }
                    }
                }
                """
            : string.Empty;

        var utilsClassDeclaration = $$"""
           public static class {{ClassName}}
           {
               {{optionalNullToNStringConverter}}

               public static string TransformQueryForSliceArgs(string originalSql, int sliceSize, string paramName)
               {
                   var paramArgs = Enumerable.Range(0, sliceSize).Select(i => $"@{paramName}Arg{i}").ToList();
                   return originalSql.Replace($"/*SLICE:{paramName}*/@{paramName}", string.Join(",", paramArgs));
               }
               
               {{optionalTransformQueryForSqliteBatch}}
           }
           """;
        return ParseMemberDeclaration(utilsClassDeclaration)!.NormalizeWhitespace();
    }
}