// auto-generated by sqlc - do not edit
// ReSharper disable UseObjectOrCollectionInitializer
// ReSharper disable UseAwaitUsing
// ReSharper disable ConvertToUsingDeclaration
// ReSharper disable NotAccessedPositionalProperty.Global
// ReSharper disable UnusedAutoPropertyAccessor.Global
using CsvHelper;
using CsvHelper.Configuration;
using CsvHelper.TypeConversion;
using MySqlConnector;
using System;
using System.Collections.Generic;
using System.Data;
using System.Globalization;
using System.IO;
using System.Text;
using System.Threading;
using System.Threading.Tasks;

namespace MysqlSqlcImpl;
public class QuerySql : IDisposable
{
    public QuerySql()
    {
    }

    public QuerySql(string connectionString) : this()
    {
        this.ConnectionString = connectionString;
        _dataSource = new Lazy<MySqlDataSource>(() =>
        {
            var builder = new MySqlConnectionStringBuilder(connectionString!);
            builder.ConnectionReset = false;
            // Pre-warm connection pool with minimum connections
            if (builder.MinimumPoolSize == 0)
                builder.MinimumPoolSize = 1;
            return new MySqlDataSourceBuilder(builder.ConnectionString).Build();
        }, LazyThreadSafetyMode.ExecutionAndPublication);
    }

    private QuerySql(MySqlTransaction transaction) : this()
    {
        this.Transaction = transaction;
    }

    public static QuerySql WithTransaction(MySqlTransaction transaction)
    {
        return new QuerySql(transaction);
    }

    private MySqlTransaction? Transaction { get; }
    private string? ConnectionString { get; }

    private readonly Lazy<MySqlDataSource>? _dataSource;
    private MySqlDataSource GetDataSource()
    {
        if (_dataSource == null)
            throw new InvalidOperationException("ConnectionString is required when not using a transaction");
        return _dataSource.Value;
    }

    private const string GetCustomerOrdersSql = @"SELECT 
                                                      o.order_id, ordered_at, order_state, total_amount, order_item_id, i.quantity, i.unit_price, 
                                                      p.product_id, p.name as product_name, p.category as product_category
                                                  FROM sales.orders o
                                                  JOIN sales.order_items i
                                                  USING (order_id)
                                                  JOIN sales.products p
                                                  USING (product_id)
                                                  WHERE o.customer_id = @customer_id
                                                  ORDER BY o.ordered_at DESC
                                                  LIMIT @limit OFFSET @offset";
    public readonly record struct GetCustomerOrdersRow(long OrderId, DateTime OrderedAt, string OrderState, decimal TotalAmount, long OrderItemId, int Quantity, decimal UnitPrice, int ProductId, string ProductName, string ProductCategory);
    public readonly record struct GetCustomerOrdersArgs(int CustomerId, int Limit, int Offset);
    public async Task<List<GetCustomerOrdersRow>> GetCustomerOrdersAsync(GetCustomerOrdersArgs args)
    {
        if (this.Transaction == null)
        {
            using (var connection = await GetDataSource().OpenConnectionAsync())
            {
                using (var command = connection.CreateCommand())
                {
                    command.CommandText = GetCustomerOrdersSql;
                    command.Parameters.AddWithValue("@customer_id", args.CustomerId);
                    command.Parameters.AddWithValue("@limit", args.Limit);
                    command.Parameters.AddWithValue("@offset", args.Offset);
                    using (var reader = await command.ExecuteReaderAsync())
                    {
                        var result = new List<GetCustomerOrdersRow>();
                        while (await reader.ReadAsync())
                            result.Add(new GetCustomerOrdersRow { OrderId = reader.GetInt64(0), OrderedAt = reader.GetDateTime(1), OrderState = reader.GetString(2), TotalAmount = reader.GetDecimal(3), OrderItemId = reader.GetInt64(4), Quantity = reader.GetInt32(5), UnitPrice = reader.GetDecimal(6), ProductId = reader.GetInt32(7), ProductName = reader.GetString(8), ProductCategory = reader.GetString(9) });
                        return result;
                    }
                }
            }
        }

        if (this.Transaction?.Connection == null || this.Transaction?.Connection.State != ConnectionState.Open)
            throw new InvalidOperationException("Transaction is provided, but its connection is null.");
        using (var command = this.Transaction.Connection.CreateCommand())
        {
            command.CommandText = GetCustomerOrdersSql;
            command.Transaction = this.Transaction;
            command.Parameters.AddWithValue("@customer_id", args.CustomerId);
            command.Parameters.AddWithValue("@limit", args.Limit);
            command.Parameters.AddWithValue("@offset", args.Offset);
            using (var reader = await command.ExecuteReaderAsync())
            {
                var result = new List<GetCustomerOrdersRow>();
                while (await reader.ReadAsync())
                    result.Add(new GetCustomerOrdersRow { OrderId = reader.GetInt64(0), OrderedAt = reader.GetDateTime(1), OrderState = reader.GetString(2), TotalAmount = reader.GetDecimal(3), OrderItemId = reader.GetInt64(4), Quantity = reader.GetInt32(5), UnitPrice = reader.GetDecimal(6), ProductId = reader.GetInt32(7), ProductName = reader.GetString(8), ProductCategory = reader.GetString(9) });
                return result;
            }
        }
    }

    public readonly record struct AddCustomersArgs(string Name, string Email, string Phone, string? Address, DateTime RegisteredAt);
    public async Task AddCustomersAsync(List<AddCustomersArgs> args)
    {
        const string supportedDateTimeFormat = "yyyy-MM-dd H:mm:ss";
        var config = new CsvConfiguration(CultureInfo.CurrentCulture)
        {
            Delimiter = ",",
            NewLine = "\n"
        };
        var nullConverterFn = new Utils.NullToStringCsvConverter();
        using (var writer = new StreamWriter("input.csv", false, new UTF8Encoding(false)))
        using (var csvWriter = new CsvWriter(writer, config))
        {
            var options = new TypeConverterOptions
            {
                Formats = new[]
                {
                    supportedDateTimeFormat
                }
            };
            csvWriter.Context.TypeConverterOptionsCache.AddOptions<DateTime>(options);
            csvWriter.Context.TypeConverterOptionsCache.AddOptions<DateTime?>(options);
            csvWriter.Context.TypeConverterCache.AddConverter<string?>(nullConverterFn);
            csvWriter.Context.TypeConverterCache.AddConverter<DateTime?>(nullConverterFn);
            await csvWriter.WriteRecordsAsync(args);
        }

        using (var connection = await GetDataSource().OpenConnectionAsync())
        {
            var loader = new MySqlBulkLoader(connection)
            {
                Local = true,
                TableName = "sales.customers",
                FileName = "input.csv",
                FieldTerminator = ",",
                FieldQuotationCharacter = '"',
                FieldQuotationOptional = true,
                NumberOfLinesToSkip = 1,
                LineTerminator = "\n"
            };
            loader.Columns.AddRange(new List<string> { "name", "email", "phone", "address", "registered_at" });
            await loader.LoadAsync();
        }
    }

    public readonly record struct AddProductsArgs(string Name, string Category, decimal UnitPrice, int StockQuantity, string? Description);
    public async Task AddProductsAsync(List<AddProductsArgs> args)
    {
        const string supportedDateTimeFormat = "yyyy-MM-dd H:mm:ss";
        var config = new CsvConfiguration(CultureInfo.CurrentCulture)
        {
            Delimiter = ",",
            NewLine = "\n"
        };
        var nullConverterFn = new Utils.NullToStringCsvConverter();
        using (var writer = new StreamWriter("input.csv", false, new UTF8Encoding(false)))
        using (var csvWriter = new CsvWriter(writer, config))
        {
            var options = new TypeConverterOptions
            {
                Formats = new[]
                {
                    supportedDateTimeFormat
                }
            };
            csvWriter.Context.TypeConverterOptionsCache.AddOptions<DateTime>(options);
            csvWriter.Context.TypeConverterOptionsCache.AddOptions<DateTime?>(options);
            csvWriter.Context.TypeConverterCache.AddConverter<string?>(nullConverterFn);
            csvWriter.Context.TypeConverterCache.AddConverter<decimal?>(nullConverterFn);
            csvWriter.Context.TypeConverterCache.AddConverter<int?>(nullConverterFn);
            await csvWriter.WriteRecordsAsync(args);
        }

        using (var connection = await GetDataSource().OpenConnectionAsync())
        {
            var loader = new MySqlBulkLoader(connection)
            {
                Local = true,
                TableName = "sales.products",
                FileName = "input.csv",
                FieldTerminator = ",",
                FieldQuotationCharacter = '"',
                FieldQuotationOptional = true,
                NumberOfLinesToSkip = 1,
                LineTerminator = "\n"
            };
            loader.Columns.AddRange(new List<string> { "name", "category", "unit_price", "stock_quantity", "description" });
            await loader.LoadAsync();
        }
    }

    public readonly record struct AddOrdersArgs(int CustomerId, string OrderState, decimal TotalAmount);
    public async Task AddOrdersAsync(List<AddOrdersArgs> args)
    {
        const string supportedDateTimeFormat = "yyyy-MM-dd H:mm:ss";
        var config = new CsvConfiguration(CultureInfo.CurrentCulture)
        {
            Delimiter = ",",
            NewLine = "\n"
        };
        var nullConverterFn = new Utils.NullToStringCsvConverter();
        using (var writer = new StreamWriter("input.csv", false, new UTF8Encoding(false)))
        using (var csvWriter = new CsvWriter(writer, config))
        {
            var options = new TypeConverterOptions
            {
                Formats = new[]
                {
                    supportedDateTimeFormat
                }
            };
            csvWriter.Context.TypeConverterOptionsCache.AddOptions<DateTime>(options);
            csvWriter.Context.TypeConverterOptionsCache.AddOptions<DateTime?>(options);
            csvWriter.Context.TypeConverterCache.AddConverter<int?>(nullConverterFn);
            csvWriter.Context.TypeConverterCache.AddConverter<string?>(nullConverterFn);
            csvWriter.Context.TypeConverterCache.AddConverter<decimal?>(nullConverterFn);
            await csvWriter.WriteRecordsAsync(args);
        }

        using (var connection = await GetDataSource().OpenConnectionAsync())
        {
            var loader = new MySqlBulkLoader(connection)
            {
                Local = true,
                TableName = "sales.orders",
                FileName = "input.csv",
                FieldTerminator = ",",
                FieldQuotationCharacter = '"',
                FieldQuotationOptional = true,
                NumberOfLinesToSkip = 1,
                LineTerminator = "\n"
            };
            loader.Columns.AddRange(new List<string> { "customer_id", "order_state", "total_amount" });
            await loader.LoadAsync();
        }
    }

    public readonly record struct AddOrderItemsArgs(long OrderId, int ProductId, int Quantity, decimal UnitPrice);
    public async Task AddOrderItemsAsync(List<AddOrderItemsArgs> args)
    {
        const string supportedDateTimeFormat = "yyyy-MM-dd H:mm:ss";
        var config = new CsvConfiguration(CultureInfo.CurrentCulture)
        {
            Delimiter = ",",
            NewLine = "\n"
        };
        var nullConverterFn = new Utils.NullToStringCsvConverter();
        using (var writer = new StreamWriter("input.csv", false, new UTF8Encoding(false)))
        using (var csvWriter = new CsvWriter(writer, config))
        {
            var options = new TypeConverterOptions
            {
                Formats = new[]
                {
                    supportedDateTimeFormat
                }
            };
            csvWriter.Context.TypeConverterOptionsCache.AddOptions<DateTime>(options);
            csvWriter.Context.TypeConverterOptionsCache.AddOptions<DateTime?>(options);
            csvWriter.Context.TypeConverterCache.AddConverter<long?>(nullConverterFn);
            csvWriter.Context.TypeConverterCache.AddConverter<int?>(nullConverterFn);
            csvWriter.Context.TypeConverterCache.AddConverter<decimal?>(nullConverterFn);
            await csvWriter.WriteRecordsAsync(args);
        }

        using (var connection = await GetDataSource().OpenConnectionAsync())
        {
            var loader = new MySqlBulkLoader(connection)
            {
                Local = true,
                TableName = "sales.order_items",
                FileName = "input.csv",
                FieldTerminator = ",",
                FieldQuotationCharacter = '"',
                FieldQuotationOptional = true,
                NumberOfLinesToSkip = 1,
                LineTerminator = "\n"
            };
            loader.Columns.AddRange(new List<string> { "order_id", "product_id", "quantity", "unit_price" });
            await loader.LoadAsync();
        }
    }

    private const string GetCustomerIdsSql = "SELECT customer_id FROM sales.customers ORDER BY customer_id LIMIT @limit";
    public readonly record struct GetCustomerIdsRow(int CustomerId);
    public readonly record struct GetCustomerIdsArgs(int Limit);
    public async Task<List<GetCustomerIdsRow>> GetCustomerIdsAsync(GetCustomerIdsArgs args)
    {
        if (this.Transaction == null)
        {
            using (var connection = await GetDataSource().OpenConnectionAsync())
            {
                using (var command = connection.CreateCommand())
                {
                    command.CommandText = GetCustomerIdsSql;
                    command.Parameters.AddWithValue("@limit", args.Limit);
                    using (var reader = await command.ExecuteReaderAsync())
                    {
                        var result = new List<GetCustomerIdsRow>();
                        while (await reader.ReadAsync())
                            result.Add(new GetCustomerIdsRow { CustomerId = reader.GetInt32(0) });
                        return result;
                    }
                }
            }
        }

        if (this.Transaction?.Connection == null || this.Transaction?.Connection.State != ConnectionState.Open)
            throw new InvalidOperationException("Transaction is provided, but its connection is null.");
        using (var command = this.Transaction.Connection.CreateCommand())
        {
            command.CommandText = GetCustomerIdsSql;
            command.Transaction = this.Transaction;
            command.Parameters.AddWithValue("@limit", args.Limit);
            using (var reader = await command.ExecuteReaderAsync())
            {
                var result = new List<GetCustomerIdsRow>();
                while (await reader.ReadAsync())
                    result.Add(new GetCustomerIdsRow { CustomerId = reader.GetInt32(0) });
                return result;
            }
        }
    }

    private const string GetProductIdsSql = "SELECT product_id FROM sales.products ORDER BY product_id LIMIT @limit";
    public readonly record struct GetProductIdsRow(int ProductId);
    public readonly record struct GetProductIdsArgs(int Limit);
    public async Task<List<GetProductIdsRow>> GetProductIdsAsync(GetProductIdsArgs args)
    {
        if (this.Transaction == null)
        {
            using (var connection = await GetDataSource().OpenConnectionAsync())
            {
                using (var command = connection.CreateCommand())
                {
                    command.CommandText = GetProductIdsSql;
                    command.Parameters.AddWithValue("@limit", args.Limit);
                    using (var reader = await command.ExecuteReaderAsync())
                    {
                        var result = new List<GetProductIdsRow>();
                        while (await reader.ReadAsync())
                            result.Add(new GetProductIdsRow { ProductId = reader.GetInt32(0) });
                        return result;
                    }
                }
            }
        }

        if (this.Transaction?.Connection == null || this.Transaction?.Connection.State != ConnectionState.Open)
            throw new InvalidOperationException("Transaction is provided, but its connection is null.");
        using (var command = this.Transaction.Connection.CreateCommand())
        {
            command.CommandText = GetProductIdsSql;
            command.Transaction = this.Transaction;
            command.Parameters.AddWithValue("@limit", args.Limit);
            using (var reader = await command.ExecuteReaderAsync())
            {
                var result = new List<GetProductIdsRow>();
                while (await reader.ReadAsync())
                    result.Add(new GetProductIdsRow { ProductId = reader.GetInt32(0) });
                return result;
            }
        }
    }

    private const string GetOrderIdsSql = "SELECT order_id FROM sales.orders ORDER BY order_id LIMIT @limit";
    public readonly record struct GetOrderIdsRow(long OrderId);
    public readonly record struct GetOrderIdsArgs(int Limit);
    public async Task<List<GetOrderIdsRow>> GetOrderIdsAsync(GetOrderIdsArgs args)
    {
        if (this.Transaction == null)
        {
            using (var connection = await GetDataSource().OpenConnectionAsync())
            {
                using (var command = connection.CreateCommand())
                {
                    command.CommandText = GetOrderIdsSql;
                    command.Parameters.AddWithValue("@limit", args.Limit);
                    using (var reader = await command.ExecuteReaderAsync())
                    {
                        var result = new List<GetOrderIdsRow>();
                        while (await reader.ReadAsync())
                            result.Add(new GetOrderIdsRow { OrderId = reader.GetInt64(0) });
                        return result;
                    }
                }
            }
        }

        if (this.Transaction?.Connection == null || this.Transaction?.Connection.State != ConnectionState.Open)
            throw new InvalidOperationException("Transaction is provided, but its connection is null.");
        using (var command = this.Transaction.Connection.CreateCommand())
        {
            command.CommandText = GetOrderIdsSql;
            command.Transaction = this.Transaction;
            command.Parameters.AddWithValue("@limit", args.Limit);
            using (var reader = await command.ExecuteReaderAsync())
            {
                var result = new List<GetOrderIdsRow>();
                while (await reader.ReadAsync())
                    result.Add(new GetOrderIdsRow { OrderId = reader.GetInt64(0) });
                return result;
            }
        }
    }

    private const string GetOrderAmountsSql = "SELECT order_id, total_amount FROM sales.orders WHERE order_id IN (/*SLICE:order_ids*/@order_id)";
    public readonly record struct GetOrderAmountsRow(long OrderId, decimal TotalAmount);
    public readonly record struct GetOrderAmountsArgs(long OrderId);
    public async Task<List<GetOrderAmountsRow>> GetOrderAmountsAsync(GetOrderAmountsArgs args)
    {
        if (this.Transaction == null)
        {
            using (var connection = await GetDataSource().OpenConnectionAsync())
            {
                using (var command = connection.CreateCommand())
                {
                    command.CommandText = GetOrderAmountsSql;
                    command.Parameters.AddWithValue("@order_id", args.OrderId);
                    using (var reader = await command.ExecuteReaderAsync())
                    {
                        var result = new List<GetOrderAmountsRow>();
                        while (await reader.ReadAsync())
                            result.Add(new GetOrderAmountsRow { OrderId = reader.GetInt64(0), TotalAmount = reader.GetDecimal(1) });
                        return result;
                    }
                }
            }
        }

        if (this.Transaction?.Connection == null || this.Transaction?.Connection.State != ConnectionState.Open)
            throw new InvalidOperationException("Transaction is provided, but its connection is null.");
        using (var command = this.Transaction.Connection.CreateCommand())
        {
            command.CommandText = GetOrderAmountsSql;
            command.Transaction = this.Transaction;
            command.Parameters.AddWithValue("@order_id", args.OrderId);
            using (var reader = await command.ExecuteReaderAsync())
            {
                var result = new List<GetOrderAmountsRow>();
                while (await reader.ReadAsync())
                    result.Add(new GetOrderAmountsRow { OrderId = reader.GetInt64(0), TotalAmount = reader.GetDecimal(1) });
                return result;
            }
        }
    }

    private const string GetProductPricesSql = "SELECT product_id, unit_price FROM sales.products WHERE product_id IN (/*SLICE:product_ids*/@product_id)";
    public readonly record struct GetProductPricesRow(int ProductId, decimal UnitPrice);
    public readonly record struct GetProductPricesArgs(int ProductId);
    public async Task<List<GetProductPricesRow>> GetProductPricesAsync(GetProductPricesArgs args)
    {
        if (this.Transaction == null)
        {
            using (var connection = await GetDataSource().OpenConnectionAsync())
            {
                using (var command = connection.CreateCommand())
                {
                    command.CommandText = GetProductPricesSql;
                    command.Parameters.AddWithValue("@product_id", args.ProductId);
                    using (var reader = await command.ExecuteReaderAsync())
                    {
                        var result = new List<GetProductPricesRow>();
                        while (await reader.ReadAsync())
                            result.Add(new GetProductPricesRow { ProductId = reader.GetInt32(0), UnitPrice = reader.GetDecimal(1) });
                        return result;
                    }
                }
            }
        }

        if (this.Transaction?.Connection == null || this.Transaction?.Connection.State != ConnectionState.Open)
            throw new InvalidOperationException("Transaction is provided, but its connection is null.");
        using (var command = this.Transaction.Connection.CreateCommand())
        {
            command.CommandText = GetProductPricesSql;
            command.Transaction = this.Transaction;
            command.Parameters.AddWithValue("@product_id", args.ProductId);
            using (var reader = await command.ExecuteReaderAsync())
            {
                var result = new List<GetProductPricesRow>();
                while (await reader.ReadAsync())
                    result.Add(new GetProductPricesRow { ProductId = reader.GetInt32(0), UnitPrice = reader.GetDecimal(1) });
                return result;
            }
        }
    }

    public void Dispose()
    {
        GC.SuppressFinalize(this);
        if (_dataSource?.IsValueCreated == true)
            _dataSource.Value.Dispose();
    }
}